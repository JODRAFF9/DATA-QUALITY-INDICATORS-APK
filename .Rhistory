x_vals <- seq(min(data), max(data), length.out = 500)
f_vals <- sapply(x_vals, function(x) fn(data, x , nb_cla = 500))
# Création du graphique de base
plot(x_vals, f_vals, type = "l", col = "green", lwd = 2,
main = "Estimation de densité", xlab = "x", ylab = "Densité")
# Ajout de la courbe de densité (déjà fait via plot)
# Tracer une ligne verticale pour le seuil
seuil_pauvrete <- 500  # Remplace par la bonne valeur
abline(v = z, col = "red", lwd = 2, lty = 2)
# Colorier l'aire sous la courbe jusqu'au seuil
x_poly <- x_vals[x_vals <= z]
y_poly <- f_vals[x_vals <= z]
polygon(c(x_poly, rev(x_poly)), c(rep(0, length(y_poly)), rev(y_poly)),
col = "red", border = NA)
# Ajout d'une légende
legend("topright",
legend = c("Densité estimée", "Seuil de pauvreté", "Population pauvre"),
col = c("green", "red", "red"),
lwd = c(2, 2, NA),
lty = c(1, 2, NA),
pch = c(NA, NA, 15),  # carré pour l’aire colorée
pt.cex = 2,
bty = "n")
# Vecteurs de base
x_vals <- seq(min(data), max(data), length.out = 500)
f_vals <- sapply(x_vals, function(x) fn(data, x , nb_cla = 500))
# Création du graphique de base
plot(x_vals, f_vals, type = "l", col = "green", lwd = 2,
main = "Estimation de densité", xlab = "x", ylab = "Densité")
# Ajout de la courbe de densité (déjà fait via plot)
# Tracer une ligne verticale pour le seuil
seuil_pauvrete <- 500  # Remplace par la bonne valeur
abline(v = z, col = "blue", lwd = 2, lty = 2)
# Colorier l'aire sous la courbe jusqu'au seuil
x_poly <- x_vals[x_vals <= z]
y_poly <- f_vals[x_vals <= z]
polygon(c(x_poly, rev(x_poly)), c(rep(0, length(y_poly)), rev(y_poly)),
col = "red", border = NA)
# Ajout d'une légende
legend("topright",
legend = c("Densité estimée", "Seuil de pauvreté", "Population pauvre"),
col = c("green", "blue", "red"),
lwd = c(2, 2, NA),
lty = c(1, 2, NA),
pch = c(NA, NA, 15),  # carré pour l’aire colorée
pt.cex = 2,
bty = "n")
# Vecteurs de base
x_vals <- seq(min(data), max(data), length.out = 500)
f_vals <- sapply(x_vals, function(x) fn(data, x , nb_cla = 500))
# Création du graphique de base
plot(x_vals, f_vals, type = "l", col = "green", lwd = 2,
main = "Analyse de la pauvreté", xlab = "x", ylab = "Densité")
# Ajout de la courbe de densité (déjà fait via plot)
# Tracer une ligne verticale pour le seuil
seuil_pauvrete <- 500  # Remplace par la bonne valeur
abline(v = z, col = "blue", lwd = 2, lty = 2)
# Colorier l'aire sous la courbe jusqu'au seuil
x_poly <- x_vals[x_vals <= z]
y_poly <- f_vals[x_vals <= z]
polygon(c(x_poly, rev(x_poly)), c(rep(0, length(y_poly)), rev(y_poly)),
col = "red", border = NA)
# Ajout d'une légende
legend("topright",
legend = c("Densité estimée", "Seuil de pauvreté", "Population pauvre"),
col = c("green", "blue", "red"),
lwd = c(2, 2, NA),
lty = c(1, 2, NA),
pch = c(NA, NA, 15),  # carré pour l’aire colorée
pt.cex = 2,
bty = "n")
View(F_n)
View(fn)
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
library(dplyr)
library(tidyr)
data <- read_excel("../data/SN_RGPH-4.xlsx")
View(data)
# Pourcentage de NA par variable
sapply(data, function(x) sum(is.na(x)) / length(x) * 100)
# nous remarquons qu'il n'existe pas de valeurs manquante dans la base
# Vérifie s'il y a des doublons
any(duplicated(data))
#il y a absence de doublons dans la base
colnames(data)
colnames(data)
# verification de la positivité des valeurs
# Liste des variables à tester
vars <- c("CONCESSIONS", "MENAGES", "HOMMES", "FEMMES", "POPULATION")
# Vérification pour chaque variable : toutes les valeurs > 0 ?
sapply(data[vars], function(x) all(x > 0))
# verifier que la somme des homme et des femmes est egale a la poluation
#dans le menage
all(data$FEMMES + data$HOMMES == data$POPULATION)
epsilon <- 1e-20
all(abs(data$FEMMES + data$HOMMES - data$POPULATION) < epsilon)
data1=data[data$FEMMES + data$HOMMES != data$POPULATION, ]
# nombre de nemage sup a concessions
all(data$MENAGES >= data$CONCESSIONS)
region_expose <- c(
"DIOURBEL", "FATICK" ,"KAFFRINE", "KEDOUGOU" ,"KOLDA", "LOUGA", "MATAM", "SAINT-LOUIS", "SEDHIOU", "TAMBACOUNDA"
)
# Base avec les départements exposés
data <- subset(data, REGION %in% region_expose)
# selection des depatements entrant dans notre etude
departements_exposes <- c(
"BAMBEY", "GOSSAS", "KOUNGHEUL", "SALEMATA", "MEDINA YORO FOULAH",
"LINGUERE", "KANEL", "MATAM", "RANEROU", "PODOR", "SEDHIOU",
"GOUDIRY", "KOUPENTOUM", "TAMBACOUNDA"
)
# Base avec les départements exposés
data <- subset(data, DEPARTEMENT %in% departements_exposes)
data_inf=data
install.packages("rmarkdown")
install.packages("rmarkdown", dependencies = TRUE)
a=c(1,2,3,4);
b=c(4,3,2,1)
corr(a,b)
corr(a;b)
cor(a,b)
cor.test(a,b)
rm
rm(list = ls())
help(cor)
require(graphics)
pairs(USJudgeRatings)
library(readxl)
data <- read_excel("data.xlsx")
install.packages('IRkernel')
IRkernel::installspec(user = TRUE)  # ajoute R à Jupyter pour l'utilisateur courant
IRkernel::installspec(user = TRUE)
IRkernel::installspec(user = TRUE)
install.packages('IRkernel')
IRkernel::installspec(user = TRUE)
library(shiny)
library(DT)
library(readxl)
library(dplyr)
library(tidyr)
library(ggplot2)
library(plotly)
# Interface utilisateur
ui <- fluidPage(
titlePanel("Analyse de la qualité des données démographiques"),
sidebarLayout(
sidebarPanel(
# Upload de fichier
fileInput("file1", "Choisir un fichier Excel",
accept = c(".xlsx", ".xls")),
# Informations
tags$hr(),
helpText("Le fichier doit contenir les colonnes : AGE, Homme, Femme, Total"),
# Sélection des indicateurs
tags$hr(),
checkboxGroupInput("indicateurs", "Indicateurs à calculer:",
choices = c("Indice de Whipple" = "whipple",
"Indice de Myers" = "myers",
"Indice de Bachi" = "bachi",
"Indice combiné Nations Unies" = "nu"),
selected = c("whipple", "myers", "bachi", "nu")),
# Paramètres de la pyramide des âges
tags$hr(),
h4("Pyramide des âges"),
radioButtons("type_pyramide", "Type de pyramide:",
choices = c("Par âge simple" = "simple",
"Groupée (quinquennale)" = "grouped"),
selected = "simple"),
conditionalPanel(
condition = "input.type_pyramide == 'grouped'",
sliderInput("largeur_groupe", "Largeur des groupes (années):",
min = 1, max = 10, value = 5, step = 1)
),
numericInput("age_max", "Âge maximum à afficher:",
value = 100, min = 10, max = 120),
# Boutons d'action
actionButton("calculate", "Calculer les indicateurs",
class = "btn-primary"),
actionButton("plot_pyramid", "Générer la pyramide",
class = "btn-success"),
# Téléchargement des résultats
tags$hr(),
downloadButton("downloadResults", "Télécharger les résultats"),
downloadButton("downloadPyramid", "Télécharger la pyramide")
),
mainPanel(
tabsetPanel(
tabPanel("Données",
DTOutput("contents")),
tabPanel("Résultats Whipple",
verbatimTextOutput("whipple_results"),
plotOutput("whipple_plot")),
tabPanel("Résultats Myers",
verbatimTextOutput("myers_results"),
plotOutput("myers_plot")),
tabPanel("Résultats Bachi",
verbatimTextOutput("bachi_results"),
plotOutput("bachi_plot")),
tabPanel("Résultats Nations Unies",
verbatimTextOutput("nu_results"),
plotOutput("nu_plot")),
tabPanel("Pyramide des âges",
plotlyOutput("pyramid_plot"),
DTOutput("pyramid_data")),
tabPanel("Rapport complet",
verbatimTextOutput("full_report"))
)
)
)
)
# Serveur
server <- function(input, output) {
# Chargement des données
data <- reactive({
req(input$file1)
tryCatch(
{
df <- read_excel(input$file1$datapath)
return(df)
},
error = function(e) {
stop(safeError(e))
}
)
})
# Affichage des données
output$contents <- renderDT({
req(data())
datatable(data(), options = list(scrollX = TRUE, pageLength = 10))
})
# Préparation des données complètes
donnees_completes <- reactive({
req(data())
df_complet <- data.frame(age = 0:99) %>%
left_join(data() %>% rename(age = AGE), by = "age") %>%
mutate(
Homme = ifelse(is.na(Homme), 0, Homme),
Femme = ifelse(is.na(Femme), 0, Femme),
Total = ifelse(is.na(Total), 0, Total)
)
return(df_complet)
})
# Fonction pour préparer les données de la pyramide
pyramid_data <- reactive({
req(donnees_completes(), input$age_max)
df <- donnees_completes() %>%
filter(age <= input$age_max)
if(input$type_pyramide == "grouped") {
# Création des groupes d'âge
largeur_groupe <- input$largeur_groupe
df <- df %>%
mutate(age_group = cut(age,
breaks = seq(0, max(age) + largeur_groupe, largeur_groupe),
right = FALSE,
labels = paste0(seq(0, max(age), largeur_groupe),
"-",
seq(largeur_groupe - 1, max(age) + largeur_groupe - 1, largeur_groupe)))) %>%
group_by(age_group) %>%
summarise(Homme = sum(Homme, na.rm = TRUE),
Femme = sum(Femme, na.rm = TRUE)) %>%
rename(age = age_group) %>%
mutate(age = as.character(age))
} else {
# Âge simple
df <- df %>%
select(age, Homme, Femme) %>%
mutate(age = as.character(age))
}
# Préparation pour la pyramide (Hommes en négatif)
df_long <- df %>%
pivot_longer(cols = c(Homme, Femme),
names_to = "Sexe",
values_to = "Effectif") %>%
mutate(Effectif = ifelse(Sexe == "Homme", -Effectif, Effectif))
return(df_long)
})
# Fonction pour créer la pyramide des âges
create_pyramid <- function() {
req(pyramid_data())
data_plot <- pyramid_data()
p <- ggplot(data_plot, aes(x = age, y = Effectif, fill = Sexe)) +
geom_bar(stat = "identity", position = "identity", alpha = 0.8) +
scale_fill_manual(values = c("Homme" = "steelblue", "Femme" = "lightpink"),
labels = c("Homme" = "Hommes", "Femme" = "Femmes")) +
coord_flip() +
labs(title = paste("Pyramide des âges -",
ifelse(input$type_pyramide == "simple", "Âge simple", "Groupée")),
x = "Âge",
y = "Effectif",
fill = "Sexe") +
scale_y_continuous(labels = function(x) format(abs(x), big.mark = " ")) +
theme_minimal() +
theme(legend.position = "bottom",
plot.title = element_text(hjust = 0.5, face = "bold"),
axis.text.x = element_text(angle = 0, hjust = 0.5))
if(input$type_pyramide == "grouped") {
p <- p + theme(axis.text.y = element_text(size = 8))
}
return(ggplotly(p) %>% layout(legend = list(orientation = "h", x = 0.3, y = -0.1)))
}
# Affichage de la pyramide
output$pyramid_plot <- renderPlotly({
req(input$plot_pyramid)
create_pyramid()
})
# Données de la pyramide
output$pyramid_data <- renderDT({
req(pyramid_data())
data_table <- pyramid_data() %>%
mutate(Effectif = abs(Effectif),
Effectif = round(Effectif, 0))
datatable(data_table,
options = list(scrollX = TRUE, pageLength = 10),
caption = "Données de la pyramide des âges")
})
# Calcul de tous les indicateurs
results <- eventReactive(input$calculate, {
req(data(), donnees_completes())
results_list <- list()
# Indice de Whipple
if("whipple" %in% input$indicateurs) {
results_list$whipple <- indice_whipple(data())
}
# Indice de Myers
if("myers" %in% input$indicateurs) {
results_list$myers <- indice_myers(data())
}
# Indice de Bachi
if("bachi" %in% input$indicateurs) {
pop_m <- donnees_completes()$Homme
pop_f <- donnees_completes()$Femme
results_list$bachi <- indice_bachi(pop_m, pop_f)
}
# Indice combiné Nations Unies
if("nu" %in% input$indicateurs) {
# Préparer les groupes quinquennaux
groupes_quinquenaux <- data.frame(
age = 0:99,
groupe = cut(0:99, breaks = seq(0, 100, 5), right = FALSE, labels = FALSE)
) %>% filter(age < 75)
pop_m_quinquenal <- groupes_quinquenaux %>%
cbind(hommes = donnees_completes()$Homme[1:nrow(groupes_quinquenaux)]) %>%
group_by(groupe) %>%
summarise(hommes = sum(hommes, na.rm = TRUE)) %>%
pull(hommes)
pop_f_quinquenal <- groupes_quinquenaux %>%
cbind(femmes = donnees_completes()$Femme[1:nrow(groupes_quinquenaux)]) %>%
group_by(groupe) %>%
summarise(femmes = sum(femmes, na.rm = TRUE)) %>%
pull(femmes)
taille_pop <- sum(pop_m_quinquenal) + sum(pop_f_quinquenal)
results_list$nu <- indice_combine_nu(pop_m_quinquenal, pop_f_quinquenal, taille_pop)
}
return(results_list)
})
# Affichage des résultats Whipple
output$whipple_results <- renderPrint({
req(results()$whipple)
cat("=== INDICE DE WHIPPLE ===\n\n")
cat("Homme:", round(results()$whipple$homme, 3), "\n")
cat("Femme:", round(results()$whipple$femme, 3), "\n")
cat("Ensemble:", round(results()$whipple$ensemble, 3), "\n\n")
cat("Interprétation:\n")
cat("1 = Aucune attraction/répulsion\n")
cat("5 = Tous les âges terminent par 0 ou 5\n")
cat("<1 = Répulsion pour ces âges\n")
})
# Affichage des résultats Myers
output$myers_results <- renderPrint({
req(results()$myers)
cat("=== INDICE DE MYERS ===\n\n")
print_indice_myers <- function(nom, data_myers) {
cat(toupper(nom), ":\n")
cat("Indice:", round(data_myers$indice, 3), "\n")
cat("Répartition Tu:\n")
print(round(data_myers$Tu, 1))
cat("\n")
}
print_indice_myers("Homme", results()$myers$homme)
print_indice_myers("Femme", results()$myers$femme)
print_indice_myers("Ensemble", results()$myers$ensemble)
cat("Interprétation:\n")
cat("≈0 = Déclarations d'âge exactes\n")
cat(">0 = Préférences pour certains chiffres terminaux\n")
cat("180 = Maximum (préférence pour un seul chiffre)\n")
})
# Affichage des résultats Bachi
output$bachi_results <- renderPrint({
req(results()$bachi)
cat("=== INDICE DE BACHI ===\n\n")
print_indice_bachi <- function(nom, data_bachi) {
cat(toupper(nom), ":\n")
cat("Indice:", round(data_bachi$indice, 3), "\n")
cat("Répartition ru:\n")
for(i in 1:10) {
cat("Chiffre", data_bachi$chiffres[i], ":", round(data_bachi$ru[i], 2), "%\n")
}
cat("\n")
}
print_indice_bachi("Masculin", results()$bachi$masculin)
print_indice_bachi("Féminin", results()$bachi$feminin)
})
# Affichage des résultats Nations Unies
output$nu_results <- renderPrint({
req(results()$nu)
cat("=== INDICE COMBINÉ DES NATIONS UNIES ===\n\n")
cat("Indice brut (I_brut):", round(results()$nu$I_brut, 2), "\n")
cat("Indice net (I_net):", round(results()$nu$I_net, 2), "\n")
cat("J_m (irrégularité masculine):", round(results()$nu$J_m, 2), "\n")
cat("J_f (irrégularité féminine):", round(results()$nu$J_f, 2), "\n")
cat("K (variation masculinité):", round(results()$nu$K, 2), "\n")
cat("Correction S:", round(results()$nu$S_correction, 2), "\n\n")
cat("Qualité des données:\n")
if (results()$nu$I_net < 20) {
cat("→ EXCELLENTE qualité (indice < 20)\n")
} else if (results()$nu$I_net < 40) {
cat("→ BONNE qualité (indice 20-40)\n")
} else if (results()$nu$I_net < 60) {
cat("→ Qualité ACCEPTABLE (indice 40-60)\n")
} else if (results()$nu$I_net < 80) {
cat("→ Qualité MÉDIOCRE (indice 60-80)\n")
} else {
cat("→ TRÈS MAUVAISE qualité (indice > 80)\n")
}
})
# Rapport complet
output$full_report <- renderPrint({
req(results())
cat("=== RAPPORT COMPLET - QUALITÉ DES DONNÉES DÉMOGRAPHIQUES ===\n\n")
# Whipple
if(!is.null(results()$whipple)) {
cat("1. INDICE DE WHIPPLE:\n")
cat("   Homme:", round(results()$whipple$homme, 3), "\n")
cat("   Femme:", round(results()$whipple$femme, 3), "\n")
cat("   Ensemble:", round(results()$whipple$ensemble, 3), "\n\n")
}
# Myers
if(!is.null(results()$myers)) {
cat("2. INDICE DE MYERS:\n")
cat("   Homme:", round(results()$myers$homme$indice, 3), "\n")
cat("   Femme:", round(results()$myers$femme$indice, 3), "\n")
cat("   Ensemble:", round(results()$myers$ensemble$indice, 3), "\n\n")
}
# Bachi
if(!is.null(results()$bachi)) {
cat("3. INDICE DE BACHI:\n")
cat("   Masculin:", round(results()$bachi$masculin$indice, 3), "\n")
cat("   Féminin:", round(results()$bachi$feminin$indice, 3), "\n\n")
}
# Nations Unies
if(!is.null(results()$nu)) {
cat("4. INDICE COMBINÉ DES NATIONS UNIES:\n")
cat("   Indice net:", round(results()$nu$I_net, 2), "\n")
cat("   Qualité: ")
if (results()$nu$I_net < 20) {
cat("EXCELLENTE\n")
} else if (results()$nu$I_net < 40) {
cat("BONNE\n")
} else if (results()$nu$I_net < 60) {
cat("ACCEPTABLE\n")
} else if (results()$nu$I_net < 80) {
cat("MÉDIOCRE\n")
} else {
cat("TRÈS MAUVAISE\n")
}
}
})
# Graphiques simples pour les indicateurs
output$whipple_plot <- renderPlot({
req(results()$whipple)
valeurs <- c(results()$whipple$homme, results()$whipple$femme, results()$whipple$ensemble)
noms <- c("Homme", "Femme", "Ensemble")
barplot(valeurs, names.arg = noms, col = "lightblue",
main = "Indice de Whipple par sexe",
ylab = "Valeur de l'indice")
abline(h = 1, col = "red", lty = 2)
})
output$myers_plot <- renderPlot({
req(results()$myers)
valeurs <- c(results()$myers$homme$indice, results()$myers$femme$indice, results()$myers$ensemble$indice)
noms <- c("Homme", "Femme", "Ensemble")
barplot(valeurs, names.arg = noms, col = "lightgreen",
main = "Indice de Myers par sexe",
ylab = "Valeur de l'indice")
})
# Téléchargement des résultats
output$downloadResults <- downloadHandler(
